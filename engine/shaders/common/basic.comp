#version 460

layout (local_size_x = 256) in;

// TODO: Put this global data in a shader include
layout (set = 0, binding = 0) uniform CameraBuffer
{
	mat4 view;
	mat4 proj;
	mat4 view_proj;
	mat4 inverse_view_proj;
	vec4 frustum_planes[6];
} camera_data;

// TODO: Put this global data in a shader include
layout (set = 0, binding = 1) uniform SceneLightingData
{
	vec4 fog_color;
	vec4 fog_distance;
	vec4 ambient_color;
	vec4 sunlight_direction;
	vec4 sunlight_color;
} scene_lighting_data;

// TODO: Put this global data in a shader include
layout (set = 0, binding = 2) uniform sampler2D textures_2D[];
layout (set = 0, binding = 2) uniform sampler3D textures_3D[];

struct EntitySceneData
{
	mat4 transform;
	vec4 bounds_pos_radius;
	vec4 bounds_extent;
	int material_index;
};

layout (std430, set = 1, binding = 0) readonly buffer EntitySceneDataBuffer
{
	EntitySceneData entities[];
} entity_data;

struct ObjectInstance
{
	uint object_id;
	uint batch_id;
};

layout (set = 1, binding = 1) readonly buffer ObjectInstanceBuffer
{
	ObjectInstance instances[];
} object_instance_buffer;

layout (set = 1, binding = 2) buffer CompactedObjectInstanceBuffer
{
	uint ids[];
} compacted_object_instance_buffer;

struct DrawCommand
{
	uint index_count;
    uint instance_count;
    uint first_index;
    int  vertex_offset;
    uint first_instance;
};

layout (set = 1, binding = 3) buffer DrawIndirectBuffer
{
	DrawCommand commands[];
} draw_indirect_buffer;

layout (push_constant) uniform constants
{
	float p00;
	float p11;
	uint draw_count;
	uint culling_enabled;
	uint occlusion_enabled;
	uint distance_check;
} draw_cull_constants;

bool is_occluded(uint object_index)
{
	return false;
}

bool is_in_frustum(uint object_index)
{
	const vec4 sphere_bounds = entity_data.entities[object_index].bounds_pos_radius;
	const vec4 center = vec4(sphere_bounds.xyz, 1.0f);
	const float radius = sphere_bounds.w;

	bool visible = true;

	visible = visible && dot(center, camera_data.frustum_planes[0]) > -radius;
	visible = visible && dot(center, camera_data.frustum_planes[1]) > -radius;
	visible = visible && dot(center, camera_data.frustum_planes[2]) > -radius;
	visible = visible && dot(center, camera_data.frustum_planes[3]) > -radius;

	if (draw_cull_constants.distance_check != 0)
	{
		visible = visible && dot(center, camera_data.frustum_planes[4]) > -radius;
		visible = visible && dot(center, camera_data.frustum_planes[5]) > -radius;
	}

	return visible || draw_cull_constants.culling_enabled == 0;
}

void main()
{
	uint g_id = gl_GlobalInvocationID.x;
	if (g_id < draw_cull_constants.draw_count)
	{
		const uint object_id = object_instance_buffer.instances[g_id].object_id;
		const bool in_frustum = is_in_frustum(object_id);
		const bool occluded = is_occluded(object_id);
		if (in_frustum && !occluded)
		{
			const uint batch_index = object_instance_buffer.instances[g_id].batch_id;
			const uint count_index = atomicAdd(draw_indirect_buffer.commands[batch_index].instance_count, 1);
			const uint instance_index = draw_indirect_buffer.commands[batch_index].first_instance + count_index;
			compacted_object_instance_buffer.ids[instance_index] = object_id;
		}
	}
}